Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
Example 2:

Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.



Solution - 

class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        #let's use KMP(Knuth Morris Pratt) alrgorithm as its TC is O(n+m)
        #where n is length of needle and m is length of haystack
        if len(needle) == 0:
            return -1
        
        #let's initialise a LPS array for longest prefix suffix
        lps = [0] * len(needle)
        prev, i = 0, 1 #this is because we need two pointers to calculate LPS of needle

        while i < len(needle):
            if needle[i] == needle[prev]:
                lps[i] = prev + 1
                i += 1
                prev += 1
            else:
                if prev == 0:
                    lps[i] = 0
                    i += 1
                else:
                    prev = lps[prev - 1] #this won't be the exact previous always, check with example when needle = "ABABAC"
        #lps helps in identifying how many exact matches we got previously, if not then we downgrade it by prev = lps[prev - 1]

        #lets' find the index of needle if present in the haystack
        i = 0 #indexing for haystack
        j = 0 #indexing for needle

        while i < len(haystack):
            if haystack[i] == needle[j]:
                i += 1
                j += 1
            else: #check carefully, that this else block is similar to what we have in lps calculation.
                if j == 0:
                    i += 1
                else:
                    j = lps[j-1]
            if j == len(needle):
                return i - j
        return -1
